---
title: "React's Architectural Flaws: A 10-Page Takedown for My Teacher"
description: "My teacher wanted a debate on why I think React is overrated. He's about to get one. A critical analysis of the VDOM, memoization hell, hooks, and the Vercel-driven mess."
publishDate: 2025-11-07
author: "Nony"
image: "/images/blog/react-takedown-full.png"
tags: ["React", "Rant", "Dev", "Astro", "JavaScript", "Architecture"]
---
My teacher recently said to me, "Well Alina, how about you write about [why you don't like React] and then we can debate it."

He has no idea what he just signed up for.

He's expecting a two-page summary. He's getting a full-blown architectural critique.

For over a decade, React has dominated. It came from Facebook (now Meta), it gave us components, and it's on 99% of all job postings. Its popularity is not up for debate.

What *is* up for debate is its **technical merit**.

A massive disconnect exists between React's market dominance and its fundamental technology. A growing number of senior devs and framework architects are saying it loud: React isn't just "overrated"; it's "fundamentally bad technology" and, for way too many projects, the "bane of web development."

This report is my validation of that sentiment.

And let's define "overrated" in a technical context: **A technology whose ubiquity—driven by corporate backing, hiring trends, and ecosystem inertia—has far outpaced its underlying architectural efficiency and developer experience, especially when compared to modern tools.**

My core argument is this: React’s foundational design choice, the **Virtual DOM (VDOM)**, was an "original sin." It was a flawed premise that has required a never-ending cascade of increasingly complex, inefficient, and error-prone "patches" to fix.

These "patches" are what you now call "modern React":
* The manual memoization "hell" of `useMemo` and `useCallback`.
* A fragmented, over-engineered state management ecosystem.
* The "untestable spaghetti" of the Hooks paradigm.
* And the latest mess, the controversial, Vercel-driven push towards server-centric paradigms.

This causal chain of complexity is the *real* source of "developer fatigue" and why so many large-scale React apps "devolve into blobs of non-deterministic async state."

So, let's start the debate.

---

## II. The Original Sin: The VDOM is "Pure Overhead"

React's entire technical premise—and its original marketing triumph—was the Virtual DOM.

The idea they sold us was simple: "Direct DOM mutations are computationally *expensive*." So, React offered a "performant" solution: an in-memory "virtual" representation of the DOM. By using this "cheap scratch pad," React could "diff" the new state of this virtual tree against the old one, and then—*in theory*—apply a minimal, batched patch to the "real" DOM.

This entire premise, however, is now widely understood to be **"bullshit marketing-speak."**

### The VDOM Myth vs. Reality

The claim that the VDOM *improves* performance is, in fact, **"quite the opposite."** The VDOM is an abstraction created for an *easier development experience* (in 2013) that **sacrifices performance** to achieve it.

Svelte creator Rich Harris has been calling this out for years, correctly identifying the VDOM as **"pure overhead."**

This overhead isn't a vague concept. It's a concrete tax you pay in multiple ways:

1.  **Memory and Initialization:** Your application must hold *at least one* (and often two, for diffing) complete representations of your UI in memory as JavaScript objects. This incurs extra memory usage and initialization time, which is *especially* detrimental on the low-end mobile devices that half the world uses.
2.  **The Diffing Cost:** The "diffing" algorithm itself is **"more work,"** not a "free" operation. Before the browser can even *begin* its own highly-optimized painting process, React must first burn CPU cycles running its *own* reconciliation algorithm just to *determine* what has changed. You're doing the browser's job, but worse, in JavaScript.
3.  **Serialization Overhead:** In weirdly complex cases, like moving React to a web worker (which people try to do to "fix" performance), you just introduce *another* layer of overhead: the cost of serializing and communicating this giant VDOM tree between threads.

### A Flawed and Outdated Premise

The VDOM's premise was flawed from the start because it was based on an outdated, jQuery-era understanding of the DOM.

**Modern browser DOM operations are *highly optimized*.** They are *not* the "expensive thing" React claimed them to be. The final render and layout/paint reflow are, and guess what? *Those are unavoidable.* The VDOM doesn't save you from that.

The success of modern **compiler-based** frameworks like **Svelte** and **SolidJS** is the definitive refutation of the VDOM's necessity. These tools prove, without a shadow of a doubt, that a compiler, operating at *build time*, can analyze component dependencies and generate highly-optimized, *direct* DOM manipulation instructions that are light-years more performant than a VDOM's clumsy runtime diff-and-patch.

### The Library Overhead: Bundle Size

This is the most obvious tax. Because React is a **runtime library** and *not* a compiler, the *entire VDOM and reconciliation engine* must be shipped to the client's browser.

This is a *massive* contributor to React's bundle size, a problem that plagues *every single* modern application. Even in 2025, devs are constantly fighting to reduce React bundle sizes to mitigate "longer load times, poor user experience, and even SEO penalties."

In stark contrast:
* **Svelte**, as a compiler, ships *minimal, surgical JavaScript*. It's "almost 22 times lighter than React" because it doesn't ship *itself*. It ships *only* the code needed to make your page interactive.
* **SolidJS**, which also avoids a VDOM, is similarly tiny. Its core is a *fraction* of the size of `react` and `react-dom` combined.

The VDOM is not just an abstract overhead; it is a **physical one**, paid for in kilobytes and milliseconds on *every single page load*.

This single, flawed architectural decision is the root cause of React's next, and most costly, flaw: its "dumb-as-a-brick" reactivity model.

---

## III. The Reactivity Model and Its Consequences: "Memoization Hell"

This is where the VDOM's "original sin" truly begins to poison the codebase.

React's default reactivity model is the *direct consequence* of the VDOM's limitations. And it is the primary driver of performance issues and code complexity in any non-trivial app.

### A. The "Re-Render Everything" Default

The core mechanism of React's reactivity is this: **a state change in a component triggers a re-render of that component and *all of its descendants*.**

Let me repeat that. *All of its descendants.*



The VDOM is an abstraction, and React components are often "impure" (a nice way of saying "a mess"). React has no fucking idea if a deeply nested child component, even one that doesn't receive new props, depends on the changed state (e.g., by consuming a Context or a ref).

To "avoid risking a stale UI," React's architecture makes a simple, brute-force trade-off: it **"err[s] on the side of too many renders."**

This "re-render everything" cascade is the *standard, default behavior*. It is the #1 source of performance bottlenecks, and the reason your app's fans start spinning when you just type in a text field.

### B. Debugging the Opaque

This default behavior is completely non-obvious to new developers. This leads to one of the most common and time-consuming tasks in all of React development: **debugging *why* a component is re-rendering.**

You're forced to use the React Profiler, which is often useless, simply stating: "Hook(s) n changed."

Thanks. Which hook? Why? This cryptic message forces a manual, prop-by-prop, function-by-function hunt to determine which *new object or function reference* is breaking memoization and causing the entire goddamn subtree to re-render for no reason.

### C. The Memoization Hell: `useMemo` and `useCallback`

Because the default behavior is catastrophically inefficient, React *forces* the developer to fix it.

React performance is an **opt-out process.**

React provides a set of "patches" to *manually* fix the default "re-render everything" model: `React.memo`, `useMemo`, and `useCallback`.

Let's be perfectly clear: **These are not "features" for optimization. They are *workarounds* for React's flawed reactivity model.**

This forces developers into what is widely known as **"useCallback Hell."**

Codebases become *littered* with these memoization hooks, polluting the actual component logic and making components completely unreadable. Your 10-line component is now 40 lines of `useMemo` and `useCallback` wrappers, just to tell React "no, seriously, this function *is* the same function as last time, I promise."

This creates an *impossible* catch-22 for developers:

1.  **Don't memoize:** Your app is slow as shit from a constant storm of excessive re-renders.
2.  **Over-memoize:** You wrap "all the things," which is "counter-productive." The cost of running all those memoization checks can *itself* be slower than just re-rendering. It also makes the code's intent "meaningless."

This entire system is a **leaky abstraction.**

The promise of React is: "Just write declarative components, and the VDOM will make it fast."
The reality of React is: "Write declarative components, watch them be slow, open the profiler, and then *manually* patch all your component props, functions, and values with memoization hooks to stop the 'declarative' model from grinding to a halt."

This forces *you*, the developer, to manually manage the internal mechanics of React's rendering, defeating the *entire fucking purpose* of the abstraction in the first place.

---

## IV. The "Untestable Spaghetti": A Critique of the Hooks Paradigm

Introduced in 2018, Hooks were meant to simplify React by replacing the verbose class component lifecycle.

Instead, they traded the *explicit boilerplate* of classes for an *implicit, "magic," and deeply bug-prone system* that has led to codebases being described as **"complete untestable spaghetti."**

### A. `useEffect`: The API of 100 Mistakes

The `useEffect` hook is the epicenter of this complexity. It is *constantly* identified as a primary source of bugs and is described by developers as **"100 mistakes waiting to be made."**

1.  **Confusing, Jargon-Based Naming:** The name "useEffect" is functional programming jargon that is *completely non-obvious* to a UI developer. As one critique notes, developers are thinking about "listener/observer functions" or "run this on mount," not "side effects." The name serves the framework's creators, not its users.
2.  **A Non-Obvious and Dangerous API:** The API itself is opaque and "non-obvious."
    * The "simplest" form, `useEffect(fn)`, is the **most dangerous.** It runs on *every single render* and is the #1 way to create an infinite loop or kill performance.
    * The "run once" form, `useEffect(fn, [])`, is *arbitrary*. How does an empty array `[]` intuitively mean "on mount" or "on startup"? It's cryptic.
    * The "cleanup" form, `return () => {}`, is a totally opaque API that is not discoverable without explicit documentation. It's a "magic" convention.
3.  **Rampant Misuse:** `useEffect` *should* be a "last choice" intended *only* for **synchronizing with external systems** (like third-party widgets, the `window` object, or a jQuery plugin). However, it is *constantly* misused for tasks it is terrible at:
    * **Derived State:** Using `useEffect` to update state based on a prop change. This is a *massive* anti-pattern. It "triggers a second render" (the first for the prop change, the second for the new state update), which causes performance degradation and "flickering" UI.
    * **Data Fetching:** This is the big one. While common (because React gives you *no* other option), this use is "easy to mess up," leading to infinite loops, race conditions, or stale data. This misuse is so rampant and so difficult to get right that it *requires* mature libraries like **TanStack Query (react-query)** just to fix the mess that `useEffect` creates.

### B. The Illusion of Composition & "Untestable Spaghetti"

The core criticism of the Hooks paradigm is that it is the **"worst thing to ever happen to React"** precisely because it **violates the separation of concerns.**

It encourages—no, *forces*—developers to "mix stateful, effectful code inside what would otherwise be a pure declarative render function."

This paradigm clash leads *directly* to "complete untestable spaghetti."

Because components using Hooks often have internal promise chains (e.g., in a `useEffect` for data fetching), they become **black boxes** that are impossible to test deterministically. There is *no way* for a test to `await` the final promise. You can't. It's *inside* the component's "magic" render cycle.

This forces developers to write fragile, non-deterministic tests filled with `await wait(0)` hacks, effectively *guessing* when the component's internal side effects have completed. It's a joke.

### C. Codebases as "Non-Deterministic Async State Blobs"

The architectural end-state of a large, mature Hooks-based application is, almost always, failure.

Codebases, as described by multiple burned-out developers, "always devolve into these blobs of non-deterministic async state with unpredictable performance."

When your state is "scattered throughout contexts, GraphQL caches, and complex hook dependency trees," it becomes **impossible to reason about.** A developer trying to debug a simple UI change "really have no idea what caused [it] to occur."

Hooks, which rely on a "global state" and a fragile, *fixed call order* (the "Rules of Hooks" are a giant red flag), are "magic" in the *worst* possible way. They are not a simple improvement on classes. They are a different, more complex, and more dangerous paradigm that traded *explicit* boilerplate for *implicit* complexity.

---

## V. The Ecosystem Maze: State Management and Developer Fatigue

React's self-described "unopinionated" nature—its status as a "library, not a framework"—is **not a feature. It is a fundamental flaw.**

This flaw is most apparent in the "fragmented" and "overwhelming" **state management ecosystem**, which is a primary source of "developer fatigue."

### A. "Ecosystem Fatigue" and "Decision Paralysis"

React's "choose your own adventure" style forces every single team into a "maze" of dependencies to solve *basic, universal application needs* like routing and state management.

This creates "decision paralysis" and "ecosystem fatigue." Teams spend *more time* "managing dependencies" and "figuring out how tools fit together" than they do solving actual business problems.

### B. The Context API Fallacy: A Leaky, Broken Built-in

React's built-in "solution" for prop-drilling, the **Context API**, is **NOT a state management tool.**

It is a "transport mechanism" or, more accurately, a form of "Dependency Injection." The state itself is still managed by `useState` or `useReducer`; Context is just the "pipe" to send it to distant components.

And this "pipe" has a *critical, performance-killing flaw*: it is **"almost guaranteed to cause... performance problems"** as an application grows.

When the state value in a Context Provider changes, **ALL components consuming that context are "forced to re-render, even if they only care about part of the data."**



If your application state (e.g., `isSidebarOpen`) and your theme state (e.g., `isDarkMode`) are in the *same provider*, every component subscribing to the theme will *also* re-render *every single time* the sidebar is toggled.

Because of this fundamental flaw, Context is *only* suitable for low-frequency updates (theme, language, auth state) and is **completely inappropriate** for high-frequency application state.

### C. Over-Engineering as the Norm

Because React's built-in tool is *fundamentally broken* for application state, developers are forced into the complex ecosystem of third-party libraries (Redux, Zustand, MobX, etc.).

This has created a culture of "overengineering," where developers go through a "state management detox" after realizing they built **"8 layers of state management just to toggle a damn modal."**

### D. The Great Misunderstanding: Server State vs. Client State

This is the most damning critique of this entire, fatiguing ecosystem: **it was largely a mistake.**

For *years*, developers and libraries (hello, Redux) debated the "best" way to manage "global state."

But the "vast, vast majority" of what developers were calling "state" was actually **remote state**—data fetched from an API that should be treated as a **CACHE**.

The React ecosystem normalized the *massive anti-pattern* of managing this server cache inside global client state libraries.

The rise of libraries like **TanStack Query (React Query)** and SWR exposed this flaw for what it was. These tools *correctly* treat server data as a cache, handling fetching, caching, invalidation, and re-fetching, thereby *eliminating the need for complex global state managers* for 80% or more of an application's state.

React's state management problem is thus a multi-layered failure:
1.  Its "unopinionated" philosophy created a vacuum.
2.  Its built-in tool (Context) is technically flawed for the job.
3.  This forced developers into a fragmented ecosystem of over-engineered tools...
4.  ...that were, themselves, built on a flawed abstraction (treating cache as client state).

What a mess.

---

## VI. The Vercel Problem: React as a Service (RaaS)

The most recent and controversial chapter in React's history is its effective **acquisition by Vercel**, the company behind the Next.js framework.

This has created a "fractured" ecosystem, with Vercel steering React's development to serve its *own commercial interests.*

### A. Vendor Lock-In and Conflicts of Interest

Vercel has hired key members of the React core team. This has created a *powerful* sense of déjà vu in the community, likening it to Joyent's control over Node.js, which eventually led to a contentious community fork.

The "overall mood" of the developer community regarding this shift is "strongly negative."

The core criticism is that **React is no longer an independent library.** It is being "steered" by Vercel to create a "tightly controlled ecosystem" that is **"optimized for selling hosting and platform services."**

This creates "vendor lock-in & cost worries," as new React features are designed to work *best*, or sometimes *only*, on Vercel's proprietary platform.

### B. Next.js: The "Leaky" and "Magical" Abstraction

Next.js is the vehicle for this new direction. While popular, it is heavily criticized by software architects as a "leaky abstraction" that "falls short on software engineering."

It is "overly complex," "tightly coupled," and violates fundamental design principles by "cram[ming]" all rendering modes (SSR, SSG, CSR) into one "blurry" mental model.

The "App Router" (introduced in Next.js 13) is the focal point of developer "hate." A poll showed **65% of developers prefer the old Pages Router.** The App Router is seen as a "disappointing" and *massive* increase in complexity, "erasing the border" between server and client. It is plagued by "constant regressions" and fails at basic necessities, with internationalization (i18n) being described as a "mess."

### C. The React Server Components (RSC) Controversy

React Server Components (RSC) is the core technology Vercel is pushing into React to enable its server-centric vision. For the wider ecosystem, it has been a *disaster*.

1.  **Horrific Developer Experience (DX):** RSCs are "terrible to implement." The error codes they produce are "horribly unhelpful or cryptic."
2.  **Ecosystem Fracture:** RSCs **break the entire existing React library ecosystem.** Maintainers of major libraries like Redux and Apollo have expressed deep "frustration" over the lack of communication, guidance, and stable APIs from the React team, leaving them unable to support the new paradigm.
3a. **New Security "Footguns":** This is my favorite. By blurring the client/server boundary, RSCs "enables more footguns for juniors." Developers are now, *horrifyingly*, putting **direct database queries "so close to client side code,"** creating a massive new attack surface. We've come full circle back to the security holes of 2005-era PHP, but this time we're calling it "modern."
4.  **Performance Shell Game:** RSCs don't eliminate performance issues; they *trade* them. The "benefit" of a faster server render is paid for with a **"no interactivity" gap,** where the page is visible but "broken" and unresponsive for *seconds* while the client-side JavaScript (the new, *larger* client-side JS) hydrates.

React is no longer a single, coherent technology. It is a "fractured" ecosystem split in two: "Classic React" (the client-side library most use) and "Vercel React" (a new, server-first paradigm being pushed by a single commercial entity).

Vercel exploited React's "identity vacuum" to redefine it, against the wishes of many in the community and at the expense of the entire library ecosystem.

---

## VII. The Sociological Trap: Resume-Driven Development (RDD)

Given the *severe* technical and architectural flaws detailed in the last six sections, the question remains: **Why is React still so dominant?**

The answer is not technical. It is **sociological.**

React's dominance is a self-perpetuating cycle known as **"Resume-Driven Development" (RDD).**

This cycle functions as follows:
1.  Companies perceive React as the "standard" and post job listings requiring "React."
2.  Developers, seeking to be employable, learn React to satisfy these job postings.
3.  This creates a massive "talent pool" of React developers.
4.  Companies, seeking to hire easily and quickly, choose React for their *next* project because of the large talent pool.
5.  The cycle repeats, reinforcing React's dominance **entirely disconnected from its technical merit.**

This phenomenon is so pronounced that some developers call it **"HR Oriented Programming."** Non-technical HR departments use "cuckoo" keyword filters, forcing developers to "stuff their resumes with as many skills and buzzwords as possible."

This is *not* a harmless HR issue; it creates **real, measurable technical debt.**

Developers, incentivized to "greenfield" projects with "new" technologies for their resumes, actively harm codebases. A concrete example from developer discussions is teams spending "far too long arguing with developers who wanted to refactor all of the working code to use hooks instead."

This refactoring was not done to *improve the product.* It was done because developers "don't want to work on technologies that are perceived as outdated."

RDD is the sociological engine that drives the adoption of the very "complexity" criticized in this report. The hype cycle *actively encourages* unnecessary refactors into the "latest state management trend" or the newest flawed paradigm (like Hooks), ensuring React's "overrated" status is a self-fulfilling prophecy that generates more complex, unmaintainable code.

---

## VIII. The "Overrated" Verdict: Superior Alternatives in 2025

React's "overrated" status is concretized by a simple fact: **modern frameworks have *solved* its core problems,** proving that its complexity is an unnecessary trade-off.

### A. Svelte: The Compiler as Framework

Svelte is a compiler that "shifts that work into a compile step." It has **no virtual DOM.**
* **The Solution to VDOM (Section II):** No VDOM means a tiny bundle size (up to "22 times lighter than React") and "superior performance."
* **The Solution to Reactivity (Section III):** Svelte is **"truly reactive."** Reactivity is a language-level default, which *eliminates* the "re-render everything" problem and the *entire* need for `useMemo` or `useCallback`.
* **The Solution to Hooks (Section IV):** Svelte has "less boilerplate" and a "gentle learning curve" because its syntax is "close to native" HTML, CSS, and JS.

### B. SolidJS: Granular Reactivity Done Right

SolidJS uses a familiar JSX syntax but is built on a "granular reactivity" model (Signals) that **skips the VDOM entirely.**
* **The Solution to VDOM (Section II):** It compiles JSX into direct, optimized DOM operations.
* **The Solution to Reactivity (Section III):** Solid offers "effortless performance" because it **does not re-render components.** When a signal (state) changes, Solid updates *only the specific DOM node* that depends on it. This is the surgical update React's VDOM only *approximates*, and it eliminates the need for `React.memo`, `useMemo`, and `useCallback`.
* **The Solution to Hooks (Section IV):** The Signal-based model is "MUCH easier to reason about" than Hooks. A developer can "get away with never using effects," avoiding the "untestable spaghetti" of `useEffect`.

### C. Astro: The "No JavaScript by Default" Model

Astro (my obsession) is a static site builder operating on a **"No JavaScript by default"** principle. This results in "lightning-fast performance." Astro's "islands" architecture allows developers to *use* React or Svelte for *small, isolated, interactive components*.

In doing so, **Astro proves that the vast majority of websites (blogs, portfolios, e-commerce) do not need a heavy client-side framework like React,** exposing its systemic use as *gross over-engineering.*

### Comparative Analysis of Architectural Flaws

| Feature | React (The "Overrated" Library) | SolidJS (The "Better React") | Svelte (The Compiler) |
| :--- | :--- | :--- | :--- |
| **Core Paradigm** | Virtual DOM (VDOM) Runtime. A library-based diffing abstraction. | Granular Reactivity (Signals). A compiler-aided, VDOM-less runtime. | Compiler. A true compiler with no runtime library. |
| **Performance Model** | **Pure Overhead.** Incurs memory/init cost. | **Exceptional Performance.** Direct DOM updates. | **Superior Performance.** No VDOM overhead. |
| **Reactivity Model** | **Cascading Re-Renders.** (Slow by default) | **Granular Updates.** (Fast by default) | **Surgical Updates.** (Fast by default) |
| **Optimization Burden** | **Manual ("Optimization Hell").** Requires `useMemo`, `useCallback` just to be usable. | **Automatic & Effortless.** No manual memoization needed. | **Automatic.** Reactivity is built-in. No memoization hooks. |
| **Bundle Size** | **Large.** Entire runtime must be shipped. | **Minimal.** Tiny, signal-based runtime. | **Near-Zero.** "Almost 22 times lighter than React." |

---

## IX. Conclusion: Life After React

This analysis confirms that the critical sentiment surrounding React is not arbitrary "hate." It is a **rational, evidence-based response to a decade of patching a flawed foundation.**

React's 2013-era **Virtual DOM** architecture is an "original sin" that created an inefficient, **re-render-by-default** reactivity model.

This core flaw necessitated a series of increasingly complex "patches," each worse than the last:
1.  The **"optimization hell"** of `useMemo` and `useCallback` just to fix the flawed reactivity.
2.  The broken **Context API**, which forced...
3.  ...a **"fragmented" and "over-engineered" state management ecosystem** that was, itself, built on the wrong abstraction (managing server cache as client state).
4.  The **"untestable spaghetti"** of the Hooks paradigm, which traded explicit boilerplate for implicit, "magic" complexity.
5.  And finally, the Vercel-driven "solution" of **React Server Components**—a "terrible," "ecosystem-breaking," "leaky abstraction" designed to serve a "commercially-driven" vendor lock-in strategy.

React's current dominance is a **sociological phenomenon, not a technical one.** It is propped up by "Resume-Driven Development," an inertial cycle that actively *encourages* the "over-engineering" and "complexity" that developers themselves decry.

The library is "overrated" because its core technical problems have been **definitively solved** by modern compilers (Svelte) and granular-reactivity frameworks (SolidJS), while its universal applicability has been refuted by content-first builders (Astro).

The persistent "developer fatigue" is a justified response.

The question for technical leaders in 2025 is no longer *if* they should move on from React, but which of the superior, modern paradigms they will adopt next.

---

So, to my teacher: **That's my research.**

The debate is over.